package com.rameshraja.peopledb.repository;

import com.rameshraja.peopledb.annotation.ID;
import com.rameshraja.peopledb.annotation.MultiSQL;
import com.rameshraja.peopledb.annotation.SQL;
import com.rameshraja.peopledb.exception.NoIDFoundException;
import com.rameshraja.peopledb.exception.UnableToConnectException;
import com.rameshraja.peopledb.exception.UnableToSaveException;
import com.rameshraja.peopledb.model.CrudOperation;

import java.sql.*;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Optional;
import java.util.function.Supplier;
import java.util.stream.IntStream;
import java.util.stream.Stream;

abstract class CrudRepository<T> {

    protected Connection connection;
    private PreparedStatement savePS;
    private PreparedStatement findByIdPS;
    private PreparedStatement countPS;
    private PreparedStatement updatePS;
    private PreparedStatement deletePS;

    public CrudRepository(Connection connection) {
        try {
            this.connection = connection;
            savePS = connection.prepareStatement(getSqlFromAnnotation(CrudOperation.SAVE, this::getSaveSql), Statement.RETURN_GENERATED_KEYS);
            findByIdPS= connection.prepareStatement(getSqlFromAnnotation(CrudOperation.FIND_BY_ID,this::getFoundByIdSql));
            countPS= connection.prepareStatement(getSqlFromAnnotation(CrudOperation.COUNT,this::getCountSql));;
            updatePS=connection.prepareStatement(getSqlFromAnnotation(CrudOperation.UPDATE, this::getUpdateSql));
            deletePS= connection.prepareStatement(getSqlFromAnnotation(CrudOperation.DELETE_ONE,this::getDeleteSql));
        } catch (SQLException e) {
            throw new UnableToConnectException("Unable to create prepared Statements");
        }
    }

    private String getSqlFromAnnotation(CrudOperation operationType, Supplier<String> getSql) {
        // get a sql values from via multiSQL annotation
        Stream<SQL> multiSqlStream = Arrays.stream(this.getClass().getDeclaredMethods())
                .filter(m -> m.isAnnotationPresent(MultiSQL.class))
                .map(m -> m.getAnnotation(MultiSQL.class))
                .flatMap(msql -> Arrays.stream(msql.value()));

        // get a sql values from via sql annotation
        Stream<SQL> sqlStream = Arrays.stream(this.getClass().getDeclaredMethods())
                .filter(m -> m.isAnnotationPresent(SQL.class))
                .map(m -> m.getAnnotation(SQL.class));

        return Stream.concat(sqlStream,multiSqlStream)
                .filter(a -> a.operationType().equals(operationType))
                .map(SQL::value)
                .findFirst().orElseGet(getSql);
    }

    /**
     *
     * @param id
     * @param entity
     * this method set the id in entity using id annotation which is use the retention policy
     */
    private void setIDFromAnnotation(Long id,T entity){
        Arrays.stream(entity.getClass().getDeclaredFields())
                .filter(f-> f.isAnnotationPresent(ID.class))
                .forEach(f->{
                    f.setAccessible(true);
                    try {
                        f.set(entity,id);
                    } catch (IllegalAccessException e) {
                        throw new RuntimeException("Unable to set Id value.");
                    }
                });
    }

    /**
     *
     * @param entity
     * @return the id of the entity object by using id annotation
     */
    private Long getIDFromAnnotation(T entity){
        return Arrays.stream(entity.getClass().getDeclaredFields())
                .filter(f-> f.isAnnotationPresent(ID.class))
                .map(f->{
                    f.setAccessible(true);
                    Long id;
                    try {
                        id=(Long) f.get(entity);
                    } catch (IllegalAccessException e) {
                        throw new RuntimeException(e);
                    }
                    return id;
                })
                .findFirst()
                .orElseThrow(()->new NoIDFoundException("No id annotation present entity"));
    }

    /**
     *
     * @param entity
     * @return entity with autogenerated id
     * @throws UnableToSaveException
     * This method accepts the entity object and save the entity object information to the database
     */
    public T save(T entity) throws UnableToSaveException {
        Long id=null;
        try {
            savePS.clearParameters();
            mapForSave(entity, savePS);
            int rowsAffected = savePS.executeUpdate();
            ResultSet rs = savePS.getGeneratedKeys();
            while (rs.next()) {
                id= rs.getLong(1);
                setIDFromAnnotation(id,entity);
            }
            System.out.println("records saved :" + rowsAffected);
        } catch (SQLException e) {
           throw new UnableToSaveException("Tried to save a person " + entity);
        }
        postSave(entity,id);
        return entity;
    }

    /**
     *
     * @param id
     * @return the optional<Entity>
     * This method finds the entity using passed id returns the Optional entity depends on whether the record exits or not in the database
     */
    public Optional<T> findByID(Long id) {
        T entity = null;
        try {
            findByIdPS.clearParameters();
            findByIdPS.setLong(1, id);
            ResultSet rs = findByIdPS.executeQuery();
            while (rs.next()) {
                entity = extractEntityFromResultSet(rs);
            }
        } catch (SQLException e) {
            throw new RuntimeException(e);
        }
        return Optional.ofNullable(entity);
    }

    /**
     *
     * @return the list of entities whose are exist in database
     */
    public List<T> findAll() {
        List<T> entities = new ArrayList<>();
        try {
            PreparedStatement ps=connection.prepareStatement(getSqlFromAnnotation(CrudOperation.FIND_ALL,this::getFindByAllSql),
                    ResultSet.TYPE_SCROLL_INSENSITIVE,
                    ResultSet.CONCUR_READ_ONLY);
            ResultSet rs = ps.executeQuery();
            while (rs.next()) {
                entities.add(extractEntityFromResultSet(rs));
            }
        } catch (SQLException e) {
            throw new RuntimeException(e);
        }
        return entities;
    }


    /**
     *
     * @return the long value which represents how many records are exist in database
     */
    public long count() {
        long count = 0;
        try {
            ResultSet rs = countPS.executeQuery();
            while (rs.next()) {
                count = rs.getLong(1);
            }
        } catch (SQLException e) {
            throw new RuntimeException(e);
        }
        return count;
    }

    /**
     *
     * @param entity
     * delete the particular entity in database
     */
    public void delete(T entity) {
        try {
            PreparedStatement preparedStatement = connection.prepareStatement(getSqlFromAnnotation(CrudOperation.DELETE_ONE,this::getDeleteSql));
            preparedStatement.setLong(1, getIDFromAnnotation(entity));
            int rowsAffected = preparedStatement.executeUpdate();
            System.out.println("records deleted : " + rowsAffected);
        } catch (SQLException e) {
            throw new RuntimeException(e);
        }
    }

    /**
     * @param entities varargs of entity
     */
    @SafeVarargs
    public final void delete(T... entities) {
        try {
            //generate question marks based on how many people are passed
            int n = entities.length;
            StringBuilder sb = new StringBuilder();
            IntStream.range(0, n).forEach(i -> sb.append("?").append(i < n - 1 ? "," : ""));
            PreparedStatement preparedStatement = connection.prepareStatement(getSqlFromAnnotation(CrudOperation.DELETE_MANY,this::getDeleteMultipleSql).replace(":ids", sb.toString()));
            for (int i = 0; i < n; i++) {
                // Here preparedStatement indexes are 1 based and arrays are zero based
                // That's the reason parameterIndexes are incremented with 1
                preparedStatement.setLong(i + 1, getIDFromAnnotation(entities[i]));
            }
            int rowsAffected = preparedStatement.executeUpdate();
            System.out.println("rows deleted : " + rowsAffected);
        } catch (SQLException e) {
            throw new RuntimeException(e);
        }
    }

    /**
     *
     * @param entity
     * @param index
     * update the old entity information with new info
     */
    public void update(T entity, int index) {
        try {
            PreparedStatement preparedStatement = connection.prepareStatement(getSqlFromAnnotation(CrudOperation.UPDATE, this::getUpdateSql));
            mapForUpdate(entity, preparedStatement);
            preparedStatement.setLong(index, getIDFromAnnotation(entity));
            int rowsAffected = preparedStatement.executeUpdate();
            System.out.println("records updated : " + rowsAffected);
        } catch (SQLException e) {
            throw new RuntimeException(e);
        }
    }


    /**
     * @return should return SQL string like:
     * "DELETE FROM PEOPLE WHERE ID IN (:ids);"
     * Be sure to include the '(:ids)' named parameter and call it ids
     */
    String getDeleteMultipleSql(){return "";};

    String getDeleteSql(){return "";};

    String getCountSql(){return "";};

    protected String getFindByAllSql(){return "";};

    protected void postSave(T entity, long id){};

    abstract T extractEntityFromResultSet(ResultSet rs) throws SQLException;

    String getSaveSql() {
        return "";
    }

    String getFoundByIdSql(){return "";};

    /**
     * @return returns the string that represent the update query of sql
     * make sure update query has where clause contain id for filter option
     */
    String getUpdateSql() {
        return "";
    }

    abstract void mapForSave(T entity, PreparedStatement ps) throws SQLException;

    abstract void mapForUpdate(T entity, PreparedStatement ps) throws SQLException;
}
